\section{Dynamic Programming}
  \subsection{Some dp patterns}
       \includeCode{c++} {Maximumu/Minimum path cost}{lhstyle}{dp_patterns/max_min_path.cpp}
       \includeCode{c++} {add operators between numbers to get max prod/sum}{lhstyle} {dp_patterns/operations_on_numbers.cpp}
       \includeCode{c++} {pick choices with no two similar consecutive choices}{lhstyle} {dp_patterns/pick_with_no_consecutive.cpp}
       \includeCode{c++} {sum S and max/min Product}{lhstyle}{dp_patterns/sum_S_max_prod.cpp}

   \subsection{DP solutions}
       \subsubsection{Max Subarray sum (Kadaneâ€™s Algorithm)}
          \includeCode{c++}{Max Subarray sum}{lhstyle}{solutions/maxSubarraySum.cpp}

       \subsubsection{Maximum Subarray Alternating Sum}
          \includeCode{c++}{Maximum Subarray Alternating Sum}{lhstyle}{solutions/maxSubarraySumAlt.cpp}


     \subsubsection{Count number of DISTINCT ordered ways to produce coins sums to x}
          \includeCode{c++}{Count distinct}{lhstyle}{solutions/countDistinct.cpp}

     \subsubsection{Min absolute difference between 2 elements from (L, R) (DP Ranges)}
          \includeCode{c++}{Min absolute difference}{lhstyle}{solutions/MinAbsDiff(L ,R).cpp}

     \subsubsection{Longest common subsequence between 2 Strings}
            \[
            \text{dp}[i][j] =
            \begin{cases}
                \max(\text{dp}[i-1][j], \text{dp}[i][j-1]) & \text{if } A_i \neq B_j \\
                \text{dp}[i-1][j-1] + 1 & \text{if } A_i = B_j
            \end{cases}
            \]

          \includeCode{c++}{LIS 2 Strings}{lhstyle}{solutions/longestCommonSubsequence2Strings.cpp}